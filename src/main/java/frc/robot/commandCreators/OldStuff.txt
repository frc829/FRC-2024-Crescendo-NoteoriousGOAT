        private static final class Constants {

                private static final class RangedSilly {
                        private static MutableMeasure<Angle> tiltAngle = MutableMeasure.ofRelativeUnits(35, Degrees);
                        private static Measure<Distance> elevatorPosition = Meters.of(0.0);
                        private static double topShooterPercent = -0.7;
                        private static double bottomShooterPercent = 0.7;
                        private static double transportPercent = 0.9;
                        private static double singulatorPercent = -0.9;
                        private static final double shooterTolerancePercent = 0.10;

                }

                private static final class Ranged {
                        private static final double shooterTolerancePercent = 0.10;
                        private static final double[] distances = new double[] {
                                        1.28,
                                        2.22,
                                        2.87,
                                        4.29,
                                        4.8514
                        };
                        private static final double[] anglesDegrees = new double[] {
                                        55.0,
                                        42.0,
                                        35.0,
                                        30.0,
                                        29.0
                        };
                        private static final Spline spline = MonotoneCubicSpline.createMonotoneCubicSpline(distances,
                                        anglesDegrees);

                }

        }

public static final Supplier<Command> createRangedSilly = () -> {
                Command elevatorTiltCommand = ResetAndHoldingCommands.setElevatorTiltUntil
                                .apply(Constants.RangedSilly.elevatorPosition)
                                .apply(Constants.RangedSilly.tiltAngle);

                Runnable speedUpShooters = () -> {
                        topShooterSubsystem.spin.accept(Constants.RangedSilly.topShooterPercent);
                        bottomShooterSubsystem.spin.accept(Constants.RangedSilly.bottomShooterPercent);
                };

                Command speedUpShootersCommand1 = Commands.run(
                                speedUpShooters,
                                topShooterSubsystem,
                                bottomShooterSubsystem);

                Command elevatorTiltShootersCommand = Commands.race(speedUpShootersCommand1, elevatorTiltCommand);

                Command speedUpShootersCommand2 = Commands.run(
                                speedUpShooters,
                                topShooterSubsystem,
                                bottomShooterSubsystem);

                BooleanSupplier shootersAtSpeed = () -> {
                        boolean condition = MathUtil.isNear(
                                        Math.abs(Constants.RangedSilly.topShooterPercent),
                                        Math.abs(topShooterSubsystem.velocity.in(Value)),
                                        Constants.RangedSilly.shooterTolerancePercent);
                        SmartDashboard.putBoolean("ShooterAt Speed", condition);
                        return condition;
                };
                Command elevatorHoldCommand = BasicCommands.HoldandStop.createForElevator.get();
                Command elevatorHoldCommand2 = BasicCommands.HoldandStop.createForElevator.get();

                Command tiltHoldCommand = BasicCommands.HoldandStop.createForTilt.get();
                Command tiltHoldCommand2 = BasicCommands.HoldandStop.createForTilt.get();

                Command transportCommand = BasicCommands.Set.Transport.create
                                .apply(Constants.RangedSilly.transportPercent);
                Command singulatorCommand = BasicCommands.Set.Singulator.create
                                .apply(Constants.RangedSilly.singulatorPercent);
                Command topShooterCommand = BasicCommands.Set.TopShooter.create
                                .apply(() -> Constants.RangedSilly.topShooterPercent);
                Command bottomShooterCommand = BasicCommands.Set.BottomShooter.create
                                .apply(() -> Constants.RangedSilly.bottomShooterPercent);

                Command continueUpToSpeed = Commands
                                .parallel(elevatorHoldCommand, tiltHoldCommand, speedUpShootersCommand2)
                                .until(shootersAtSpeed);

                Command shootCommands = Commands
                                .parallel(elevatorHoldCommand2, tiltHoldCommand2, transportCommand, singulatorCommand,
                                                topShooterCommand, bottomShooterCommand);

                Command command = Commands.sequence(elevatorTiltShootersCommand, continueUpToSpeed,
                                shootCommands);
                command.setName("Fender Score");
                return command;
        };

        public static final Supplier<Command> createFenderWithDelay = () -> {
                Command elevatorTiltCommand = ResetAndHoldingCommands.setElevatorTiltUntil
                                .apply(Constants.Fender.elevatorPosition)
                                .apply(Constants.Fender.tiltAngle);

                Runnable speedUpShooters = () -> {
                        topShooterSubsystem.spin.accept(Constants.Fender.topShooterPercent);
                        bottomShooterSubsystem.spin.accept(Constants.Fender.bottomShooterPercent);
                };

                Command speedUpShootersCommand1 = Commands.run(
                                speedUpShooters,
                                topShooterSubsystem,
                                bottomShooterSubsystem);

                Command elevatorTiltShootersCommand = Commands.race(speedUpShootersCommand1, elevatorTiltCommand);

                Command speedUpShootersCommand2 = Commands.run(
                                speedUpShooters,
                                topShooterSubsystem,
                                bottomShooterSubsystem);

                BooleanSupplier shootersAtSpeed = () -> {
                        boolean condition = MathUtil.isNear(
                                        Math.abs(Constants.Fender.topShooterPercent),
                                        Math.abs(topShooterSubsystem.velocity.in(Value)),
                                        Constants.Fender.shooterTolerancePercent);
                        SmartDashboard.putBoolean("ShooterAt Speed", condition);
                        return condition;
                };
                Command elevatorHoldCommand = BasicCommands.HoldandStop.createForElevator.get();
                Command elevatorHoldCommand2 = BasicCommands.HoldandStop.createForElevator.get();
                Command elevatorHoldCommand3 = BasicCommands.HoldandStop.createForElevator.get();

                Command tiltHoldCommand = BasicCommands.HoldandStop.createForTilt.get();
                Command tiltHoldCommand2 = BasicCommands.HoldandStop.createForTilt.get();
                Command tiltHoldCommand3 = BasicCommands.HoldandStop.createForTilt.get();

                Command transportCommand = BasicCommands.Set.Transport.create.apply(Constants.Fender.transportPercent);
                Command singulatorCommand = BasicCommands.Set.Singulator.create
                                .apply(Constants.Fender.singulatorPercent);

                Command transportCommand2 = BasicCommands.Set.Transport.create.apply(Constants.Fender.transportPercent);
                Command singulatorCommand2 = BasicCommands.Set.Singulator.create
                                .apply(Constants.Fender.singulatorPercent);

                Command topShooterCommand = BasicCommands.Set.TopShooter.create
                                .apply(() -> Constants.Fender.topShooterPercent);
                Command bottomShooterCommand = BasicCommands.Set.BottomShooter.create
                                .apply(() -> Constants.Fender.bottomShooterPercent);

                Command topShooterCommand2 = BasicCommands.Set.TopShooter.create
                                .apply(() -> Constants.Fender.topShooterPercent);
                Command bottomShooterCommand2 = BasicCommands.Set.BottomShooter.create
                                .apply(() -> Constants.Fender.bottomShooterPercent);

                Command continueUpToSpeed = Commands
                                .parallel(elevatorHoldCommand, tiltHoldCommand, speedUpShootersCommand2)
                                .until(shootersAtSpeed);

                Command waitUntilNoteHasExited = Commands.waitUntil(() -> !notedLoadedSubsystem.hasNote.getAsBoolean());
                Command waitUntilTime = Commands.waitSeconds(Constants.Fender.endOfShootDelay);

                Command shootCommands = Commands
                                .race(elevatorHoldCommand2, tiltHoldCommand2, transportCommand, singulatorCommand,
                                                topShooterCommand, bottomShooterCommand, waitUntilNoteHasExited);

                Command finishShoot = Commands.race(elevatorHoldCommand3, tiltHoldCommand3, transportCommand2,
                                singulatorCommand2,
                                topShooterCommand2, bottomShooterCommand2, waitUntilTime);

                Command stopTopShooter = Commands.runOnce(topShooterSubsystem.stop, topShooterSubsystem);
                Command stopBottomShooter = Commands.runOnce(bottomShooterSubsystem.stop, bottomShooterSubsystem);

                Command command = Commands.sequence(elevatorTiltShootersCommand, continueUpToSpeed,
                                shootCommands, finishShoot, stopTopShooter, stopBottomShooter);
                command.setName("Fender Score with Delay");
                return command;
        };

            public static final Supplier<Command> distanceBasedShooterAdjust = () -> {
        Runnable shooterAdjust = () -> {
            Pose2d fieldPosition = RobotContainer.telemetrySubsystem.poseEstimate.get();
            Optional<Alliance> alliance = DriverStation.getAlliance();

            if (alliance.get() == Alliance.Red) {
                Translation2d targetVector = Constants.speakerRedVector.minus(fieldPosition.getTranslation());
                double distanceMeters = targetVector.getNorm();
                double velocity = 9.8
                        * (distanceMeters * distanceMeters
                                + 4 * Constants.speakerHeight.in(Meters) * Constants.speakerHeight.in(Meters))
                        / Constants.speakerHeight.in(Meters);
                velocity = Math.sqrt(velocity);
                double shooterOmega = velocity / Constants.shooterWheelRadius.in(Meters);
                shooterOmega /= Constants.shooterSpeedTransferEfficiency;
                double shooterPercent = shooterOmega / Constants.maxShooterSpeed.in(RadiansPerSecond);
                RobotContainer.topShooterSubsystem.spin.accept(shooterPercent);
                RobotContainer.bottomShooterSubsystem.spin.accept(shooterPercent);
            } else {
                Translation2d targetVector = Constants.speakerBlueVector.minus(fieldPosition.getTranslation());
                double distanceMeters = targetVector.getNorm();
                double velocity = 9.8
                        * (distanceMeters * distanceMeters
                                + 4 * Constants.speakerHeight.in(Meters) * Constants.speakerHeight.in(Meters))
                        / Constants.speakerHeight.in(Meters);
                velocity = Math.sqrt(velocity);
                double shooterOmega = velocity / Constants.shooterWheelRadius.in(Meters);
                shooterOmega /= Constants.shooterSpeedTransferEfficiency;
                double shooterPercent = shooterOmega / Constants.maxShooterSpeed.in(RadiansPerSecond);
                RobotContainer.topShooterSubsystem.spin.accept(shooterPercent);
                RobotContainer.bottomShooterSubsystem.spin.accept(shooterPercent);
            }
        };
        Command command = Commands.run(shooterAdjust, RobotContainer.topShooterSubsystem,
                RobotContainer.bottomShooterSubsystem);
        command.setName("Distance Based Adjust");
        return command;
    };

            @SuppressWarnings({ "resource" })
        public static final Supplier<Command> createPointingFieldCentricCommand = () -> {
                ChassisSpeeds speeds = new ChassisSpeeds();
                Translation2d cor = new Translation2d();
                PIDController rotationPID = new PIDController(2.5, 0, 0);
                rotationPID.enableContinuousInput(-180, 180);
                rotationPID.setTolerance(2);
                Runnable drive = () -> {

                        var pose = telemetrySubsystem.fieldDetectorsPositions.get(1).getSecond().get();
                        if (pose.isPresent()) {
                                telemetrySubsystem.setPoseEstimator.accept(pose.get());
                        }
                        double flipper = 1;
                        var color = DriverStation.getAlliance();
                        if (color.isPresent() && color.get() == Alliance.Red) {
                                flipper *= -1;
                        }

                        speeds.vxMetersPerSecond = DriveSubsystem.Constants.maxLinearVelocity
                                        .in(MetersPerSecond) * RobotContainer.driver.leftYValue.getAsDouble();
                        speeds.vyMetersPerSecond = DriveSubsystem.Constants.maxLinearVelocity
                                        .in(MetersPerSecond) * RobotContainer.driver.leftXValue.getAsDouble();

                        Rotation2d targetRotation = new Rotation2d();

                        speeds.vxMetersPerSecond *= flipper;
                        speeds.vyMetersPerSecond *= flipper;
                        double measurement = 0;
                        Pose2d fieldPose = telemetrySubsystem.poseEstimate.get();
                        if (DriverStation.getAlliance().isPresent()
                                        && DriverStation.getAlliance().get() == Alliance.Red) {
                                measurement = telemetrySubsystem.poseEstimate.get().getRotation().unaryMinus()
                                                .getDegrees();
                                Translation2d targetVector = Constants.speakerRedVector
                                                .minus(fieldPose.getTranslation());
                                targetRotation = targetVector.getAngle().unaryMinus()
                                                .rotateBy(Rotation2d.fromDegrees(180));

                        } else {
                                measurement = telemetrySubsystem.poseEstimate.get().getRotation()
                                                .getDegrees();
                                Translation2d targetVector = Constants.speakerBlueVector
                                                .minus(fieldPose.getTranslation());
                                targetRotation = targetVector.getAngle()
                                                .rotateBy(Rotation2d.fromDegrees(180));
                        }
                        speeds.omegaRadiansPerSecond = Math
                                        .toRadians(rotationPID.calculate(measurement, targetRotation.getDegrees()));

                        speeds.omegaRadiansPerSecond *= flipper;
                        ChassisSpeeds adjustedSpeeds = ChassisSpeeds.fromFieldRelativeSpeeds(speeds,
                                        RobotContainer.telemetrySubsystem.poseEstimate.get()
                                                        .getRotation());
                        speeds.vxMetersPerSecond = adjustedSpeeds.vxMetersPerSecond;
                        speeds.vyMetersPerSecond = adjustedSpeeds.vyMetersPerSecond;
                        speeds.omegaRadiansPerSecond = adjustedSpeeds.omegaRadiansPerSecond;
                        RobotContainer.driveSubsystem.controlRobotChassisSpeeds.apply(cor).accept(speeds);
                };
                Command command = Commands.run(drive,
                                RobotContainer.driveSubsystem);
                command.setName("Manual Rotation Along Heading Field Centric");
                return command;
        };

                        public static final Translation2d speakerBlueVector = new Translation2d(0, 5.544638);
                public static final Translation2d speakerRedVector = new Translation2d(16.542, 5.544638);